(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{388:function(t,e,v){t.exports=v.p+"assets/img/mvvm.aef61c85.png"},389:function(t,e,v){t.exports=v.p+"assets/img/vue-hook.6f2c97f0.png"},463:function(t,e,v){"use strict";v.r(e);var a=v(44),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue中好的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中好的问题"}},[t._v("#")]),t._v(" vue中好的问题")]),t._v(" "),a("h2",{attrs:{id:"什么是mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是mvvm"}},[t._v("#")]),t._v(" 什么是MVVM")]),t._v(" "),a("p",[t._v("MVVM最早是由微软提出来，他借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯js对象（data）表示，view负责显示（页面），两者做到了最大限度的分离，把Model和view关联起来就是viewmodel。")]),t._v(" "),a("p",[t._v("viewmodel负责把model的数据同步到view显示出来，还负责把view的修改同步会model，view和model之间的同步工作完全是自动的，无需人为干涉")]),t._v(" "),a("p",[t._v("因此开发者只需要关注逻辑，不需要手动操作dom，不需要关注数据状态的同步问题，复杂的数据状态维护完全由mvvm来统一管理")]),t._v(" "),a("p",[a("img",{attrs:{src:v(388),alt:"图解"}})]),t._v(" "),a("h2",{attrs:{id:"mvvm与mvc的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm与mvc的区别"}},[t._v("#")]),t._v(" MVVM与MVC的区别")]),t._v(" "),a("p",[t._v("MVC----有一个Controller（C），使用Model通过控制Controller去控制view的更新，只是做到了Model层级的变化去实时改变view层的变化")]),t._v(" "),a("p",[t._v("MVVM---就是Model层和View层只互通的，两者任何一个修改都会试对方发生变化，并且两者做到了最大限度的分离")]),t._v(" "),a("h2",{attrs:{id:"amd、cmd、commonjs、和es6的对比（模块化开发）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#amd、cmd、commonjs、和es6的对比（模块化开发）"}},[t._v("#")]),t._v(" AMD、CMD、CommonJS、和ES6的对比（模块化开发）")]),t._v(" "),a("ol",[a("li",[t._v("AMD --- requireJS（异步模块）")])]),t._v(" "),a("p",[t._v("define定义，require引入")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("CMD --- SeaJS（同步模块）")])]),t._v(" "),a("p",[t._v("define定义，require引入")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("CommonJS  module.exports（nodeJS）")])]),t._v(" "),a("p",[a("code",[t._v("exports.DEFAULT_COLOR = '#409eff'")]),t._v("定义，require引入")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("ES6特性 export/import")])]),t._v(" "),a("h2",{attrs:{id:"vue优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue优点"}},[t._v("#")]),t._v(" vue优点")]),t._v(" "),a("p",[t._v("mvvm优点就是vue优点：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("数据和视频之间的的同步工作完全是自动的，无需人为的干涉，所以开发者只需关注业务逻辑")])]),t._v(" "),a("li",[a("p",[t._v("不需要手动操作dom，不需要关注数据状态的同步问题，复杂的数据状态维护完全由mvvm来统一管理，节省了很多精力")])])]),t._v(" "),a("h2",{attrs:{id:"vue的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的生命周期"}},[t._v("#")]),t._v(" vue的生命周期")]),t._v(" "),a("p",[a("img",{attrs:{src:v(389),alt:"图解"}})]),t._v(" "),a("h2",{attrs:{id:"数据双向绑定原理（自我事项最简单的数据双绑）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据双向绑定原理（自我事项最简单的数据双绑）"}},[t._v("#")]),t._v(" 数据双向绑定原理（自我事项最简单的数据双绑）")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/JavaScript/对象.html#其他方法"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"v-if和v-show的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show的区别"}},[t._v("#")]),t._v(" v-if和v-show的区别")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("v-if是‘真正’的条件渲染，因为它会确保在切换过程中条件快中的子组件会被销毁和重建")])]),t._v(" "),a("li",[a("p",[t._v("v-show知识单纯的控制display，不管true/false都会加载和渲染")])])]),t._v(" "),a("p",[t._v("选择： 两者来比较就知道，v-if开销比较大，v-show只是在开始的时候有开销，如果是十分频繁的操作，建议使用v-show，如果是加载进入总是默认值加载，建议使用v-if")]),t._v(" "),a("h2",{attrs:{id:"组件传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件传值"}},[t._v("#")]),t._v(" 组件传值")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("parent----\x3echild 通过prop")])]),t._v(" "),a("li",[a("p",[t._v("child----\x3eparent 通过$emit")])]),t._v(" "),a("li",[a("p",[t._v("child----\x3echild 通过eventBus/vuex")])])]),t._v(" "),a("h2",{attrs:{id:"计算属性（computed）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算属性（computed）"}},[t._v("#")]),t._v(" 计算属性（computed）")]),t._v(" "),a("p",[t._v("计算属性的定义：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("当依赖的属性发生变化的时候，计算属性会重新计算，反之则使用缓存中的属性值")])]),t._v(" "),a("li",[a("p",[t._v("计算属性和vue中的data的数据一样，都是响应式的，只不过他必须依赖某一个或者多个数据实现，并且只有他依赖的数据值变了。他才会更新")])])]),t._v(" "),a("h2",{attrs:{id:"watch的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch的作用"}},[t._v("#")]),t._v(" watch的作用")]),t._v(" "),a("p",[t._v("watch主要作用是监听某个数据值的变化。和计算属性相比除了没有缓存，作用是一样的")]),t._v(" "),a("h2",{attrs:{id:"vue-router相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router相关"}},[t._v("#")]),t._v(" vue-router相关")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/Vue/vue-router的两种mode.html#vue-router"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[t._v("#")]),t._v(" keep-alive")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/Vue/keep-alive.html"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"mixins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mixins"}},[t._v("#")]),t._v(" mixins")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/Vue/mixins.html"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"自定义指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[t._v("#")]),t._v(" 自定义指令")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/Vue/自定义指令.html"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[t._v("#")]),t._v(" diff算法")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/Vue/diff.html"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"vue-react中key的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-react中key的作用"}},[t._v("#")]),t._v(" vue/react中key的作用")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("不带key的情况下，对于简单列表页渲染来说diff节点更快，这一点没有错误，但是显然这不是key的作用")])]),t._v(" "),a("li",[a("p",[t._v("key的作用是什么呢？")])])]),t._v(" "),a("blockquote",[a("p",[t._v("首先一点要知道，key是给每一个vnode的唯一id，可以依靠key更准确更快地拿到oldVnode中对应的vnode节点")])]),t._v(" "),a("ul",[a("li",[t._v("更准确：带key就不可以"),a("code",[t._v("就地复用")]),t._v("，在sameNode函数"),a("code",[t._v("a.key === b.key")]),t._v("对比中可以避免就地复用的情况，所以更加准确")]),t._v(" "),a("li",[t._v("更快：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快（也就是说map是比遍历更快的）")])]),t._v(" "),a("back-to-top")],1)}),[],!1,null,null,null);e.default=r.exports}}]);